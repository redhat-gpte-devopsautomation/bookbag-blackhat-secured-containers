:guid: %guid%,
:bastion_public_hostname: %bastion_public_hostname%,
:bastion_ssh_password: %bastion_ssh_password%,
:bastion_ssh_user_name: %bastion_ssh_user_name%,

=== Relocate Application To Primary

[arabic]
In this section of the workshop, we will introduce Tekton Chains, which enables image signing in our pipelines i.e. any image built in our pipeline will be signed using a private key.  A public key will be used to verify signatures.  Tekton has a few options available to sign your images:

* x509
* Cosign
* KMS
* EXPERIMENTAL: Keyless signing

In this workshop, we will be using Cosign.
To get started signing things in Chains, you must generate a keypair and instruct Chains to sign with it via an Openshift secret. Chains expect a private key and password, if the key is encrypted, to exist in a Kubernetes secret signing-secrets in the openshift-pipelines namespace.

. Login into your bastion server by executing the below command:
+
[source, subs="attributes", role="execute"]
----
ssh -o StrictHostKeyChecking=no %bastion_ssh_user_name%@%bastion_public_hostname%
----
+
Use the below password:
+
[source, subs="attributes", role="execute"]
----
%bastion_ssh_password%
----
+
. Configure Tekton Chains by running the below commands:
+
[source, subs="attributes", role="execute"]
----
cd
cat <<EOF >> chains.yaml
apiVersion: operator.tekton.dev/v1alpha1
kind: TektonChain
metadata:
  name: chain
spec:
  artifacts.oci.storage: oci
  artifacts.taskrun.format: in-toto
  artifacts.taskrun.storage: oci
  config: {}
  targetNamespace: openshift-pipelines
  transparency.enabled: true
EOF
oc apply -f chains.yaml
----